# AI開発における課題別のツール選定基準（2026年版）

> **作成日**: 2026-01-22
> **対象**: スタートアップ・中小規模開発チーム向け
> **前提**: MA-Pilotプロジェクト（React + TypeScript + FastAPI + Supabase）の知見を基に作成

---

## 目次

1. [フロントエンド開発の課題](#1-フロントエンド開発の課題)
2. [バックエンド開発の課題](#2-バックエンド開発の課題)
3. [統合テストの課題](#3-統合テストの課題)
4. [デプロイの課題](#4-デプロイの課題)
5. [保守・運用の課題](#5-保守運用の課題)
6. [プロジェクト規模別推奨構成](#6-プロジェクト規模別推奨構成)
7. [コスト比較表](#7-コスト比較表)
8. [実践事例から学ぶ教訓](#8-実践事例から学ぶ教訓)

---

## 1. フロントエンド開発の課題

### 1.1 UI崩れ・レイアウトの課題

#### 課題の詳細
- 複数ブラウザでのレンダリング差異
- レスポンシブデザインの崩れ
- コンポーネント間のスタイル競合
- 複数人開発でのスタイル不統一

#### 推奨ツール

| ツール | 用途 | 評価 | 備考 |
|--------|------|------|------|
| **Tailwind CSS** | ユーティリティファーストCSS | ⭐⭐⭐⭐⭐ | スタイル崩れが少なく、複数人開発に最適 |
| **CSS Modules** | スコープドCSS | ⭐⭐⭐⭐ | Reactと相性良好 |
| **Emotion/styled-components** | CSS-in-JS | ⭐⭐⭐ | 動的スタイルに強い |
| **MUI (Material-UI) v6** | UIコンポーネントライブラリ | ⭐⭐⭐⭐⭐ | デザインシステム構築が容易 |

#### 実践的アプローチ
```typescript
// Tailwind CSS + MUIの組み合わせ例（MA-Pilotで採用）
import { Box, Card } from '@mui/material';

export const DashboardCard = ({ children }: Props) => {
  return (
    <Card className="p-4 shadow-lg hover:shadow-xl transition-shadow">
      <Box className="flex flex-col gap-4">
        {children}
      </Box>
    </Card>
  );
};
```

#### ブラウザ互換性対応
- **2026年の新基準**: `Baseline`を基準に技術判断
- **従来**: Can I Use + Polyfill
- **推奨ツール**: Autoprefixer、Browserslist
- **注意点**: MUI v6はv5からの破壊的変更あり、移行ガイド必須参照

**参考資料**:
- [2025年版｜今どきのフロントエンド技術＆トレンドまるっと解説！](https://devworks.jp/blog/229)
- [2025年のWebフロントエンドのふりかえりと2026年](https://www.docswell.com/s/sakito/ZEY2P7-burikaigi2026)

---

### 1.2 パフォーマンスの課題

#### 課題の詳細
- 初期レンダリング速度の遅延
- 大規模データ表示時のラグ
- 不要な再レンダリング
- バンドルサイズの肥大化

#### 推奨ツール・手法

| 手法/ツール | 効果 | 実装難易度 | 備考 |
|------------|------|-----------|------|
| **React.memo** | 不要な再レンダリング防止 | ⭐ | 基本中の基本 |
| **useMemo/useCallback** | 計算コスト削減 | ⭐⭐ | 過度な使用は逆効果 |
| **Code Splitting** | 初期ロード時間短縮 | ⭐⭐⭐ | react-loadableで実装 |
| **Lazy Loading** | 画像・コンポーネント遅延読込 | ⭐⭐ | React.lazy + Suspense |
| **React Query** | サーバー状態管理・キャッシュ | ⭐⭐⭐ | MA-Pilotで採用 |
| **Svelte** | 仮想DOM不使用 | ⭐⭐⭐⭐ | 新規プロジェクト向け |

#### 実装事例（Wondernuts社）
```typescript
// Code Splittingにより1.85倍の高速化を実現
// Before: 4560ms → After: 2685ms

import Loadable from 'react-loadable';

const AsyncDashboard = Loadable({
  loader: () => import('./Dashboard'),
  loading: LoadingSpinner,
});
```

#### パフォーマンス計測ツール
- **React Developer Tools Profiler**: レンダリング時間の可視化
- **Lighthouse**: Core Web Vitals測定
- **webpack-bundle-analyzer**: バンドルサイズ分析

#### Early Returnパターンによる最適化
```typescript
// 10-15%のパフォーマンス改善（2025年6月事例）
function validateUser(user: User) {
  if (!user) return { valid: false, error: 'User not found' };
  if (!user.email) return { valid: false, error: 'Email required' };
  if (!user.role) return { valid: false, error: 'Role required' };
  // 後続処理...
  return { valid: true };
}
```

**参考資料**:
- [Reactのパフォーマンス改善でjsの実行速度を1.85倍早くしたお話](https://medium.com/@wondernuts.staff/react%E3%81%AE%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E6%94%B9%E5%96%84%E3%81%A7js%E3%81%AE%E5%AE%9F%E8%A1%8C%E9%80%9F%E5%BA%A6%E3%82%921-85%E5%80%8D%E6%97%A9%E3%81%8F%E3%81%97%E3%81%9F%E3%81%8A%E8%A9%B1-7cc9b9d61773)
- [【すぐできる】処理速度改善3選(TypeScriptを例に)](https://qiita.com/sogenasano/items/77e4acb35cc2face2200)
- [Reactパフォーマンス改善の第一歩: 簡単にレンダリング時間を測る方法](https://iret.media/155410)

---

### 1.3 型安全性・開発体験の課題

#### 課題の詳細
- 実行時エラーの頻発
- APIレスポンス型の不一致
- リファクタリング時の不安
- チーム間での型定義の不統一

#### 推奨ツール

| ツール | 用途 | 評価 | 備考 |
|--------|------|------|------|
| **TypeScript 5.x** | 型安全性の確保 | ⭐⭐⭐⭐⭐ | 2026年は約80%のプロジェクトが採用 |
| **Zod** | スキーマバリデーション | ⭐⭐⭐⭐⭐ | 実行時バリデーション+型推論 |
| **tRPC** | End-to-End型安全なAPI | ⭐⭐⭐⭐ | フルスタックTypeScriptプロジェクト向け |
| **GraphQL + Codegen** | API型自動生成 | ⭐⭐⭐⭐ | 大規模プロジェクト向け |

#### 実装例（MA-Pilot）
```typescript
// フロントエンド: src/types/index.ts
// バックエンド: backend/src/types/index.ts
// → 常に同期を保つことで型安全性を確保

export type UserRole = 'system_admin' | 'clinic_owner' | 'clinic_editor' | 'clinic_viewer';

export interface MonthlyData {
  id: string;
  clinic_id: string;
  year_month: string;
  revenue: number;
  patient_count: number;
  // ...
}

// Zodによるバリデーション
import { z } from 'zod';

const monthlyDataSchema = z.object({
  revenue: z.number().min(0),
  patient_count: z.number().int().min(0),
  // ...
});
```

**参考資料**:
- [typescript with react 実践ガイド：導入から型安全な開発まで](https://fullfront.co.jp/blog/technology-development/typescript/react-typescript-component-hooks-typesafety/)
- [TypeScriptでのパフォーマンス最適化とデバッグテクニック](https://props-room.com/articles/handbook/typescript-guide-612)

---

### 1.4 状態管理の課題

#### 課題の詳細
- グローバル状態の複雑化
- サーバー状態とクライアント状態の混在
- 状態更新時の予期しない副作用
- パフォーマンスへの影響

#### 推奨ツール

| ツール | 用途 | 学習コスト | 適用規模 |
|--------|------|-----------|---------|
| **Zustand** | クライアント状態管理 | ⭐ | 小〜中規模 |
| **React Query** | サーバー状態管理 | ⭐⭐ | 全規模 |
| **Redux Toolkit** | 複雑な状態管理 | ⭐⭐⭐⭐ | 大規模 |
| **Jotai** | アトミックな状態管理 | ⭐⭐ | 小〜中規模 |
| **Recoil** | React公式推奨 | ⭐⭐⭐ | 中〜大規模 |

#### MA-Pilotでの採用例
```typescript
// Zustand: シンプルで直感的なグローバル状態管理
import { create } from 'zustand';

interface UserStore {
  user: User | null;
  setUser: (user: User | null) => void;
  clearUser: () => void;
}

export const useUserStore = create<UserStore>((set) => ({
  user: null,
  setUser: (user) => set({ user }),
  clearUser: () => set({ user: null }),
}));

// React Query: サーバー状態管理とキャッシュ
import { useQuery } from '@tanstack/react-query';

export const useMonthlyData = (clinicId: string, yearMonth: string) => {
  return useQuery({
    queryKey: ['monthlyData', clinicId, yearMonth],
    queryFn: () => api.getMonthlyData(clinicId, yearMonth),
    staleTime: 5 * 60 * 1000, // 5分間キャッシュ
  });
};
```

#### 状態管理の設計原則
- **分離の原則**: サーバー状態とクライアント状態を明確に分ける
- **最小化**: グローバル状態は必要最小限に
- **不変性**: 状態の直接変更を避ける
- **正規化**: ネストした状態は正規化して管理

**参考資料**:
- [フロントエンド開発の最新トレンドとは？注目技術と未来の展望](https://www.iamjava.com/article0049/)

---

## 2. バックエンド開発の課題

### 2.1 API設計の課題

#### 課題の詳細
- RESTful設計の不統一
- エンドポイント命名の混乱
- バージョニング戦略の欠如
- ドキュメントのメンテナンス負荷

#### 推奨ツール

| ツール | 用途 | 評価 | 備考 |
|--------|------|------|------|
| **FastAPI** | Pythonフレームワーク | ⭐⭐⭐⭐⭐ | 自動バリデーション、OpenAPI対応 |
| **Swagger/OpenAPI** | API仕様書自動生成 | ⭐⭐⭐⭐⭐ | FastAPIは標準搭載 |
| **Postman** | API開発・テスト | ⭐⭐⭐⭐ | チーム共有機能あり |
| **Stoplight** | API設計ファーストツール | ⭐⭐⭐⭐ | デザインレビュー機能 |

#### API設計のベストプラクティス（2026年版）

##### 1. 命名規則
```yaml
基本ルール:
  - RESTful形式を厳守
  - 複数形を使用（/clinics, /simulations）
  - ケバブケース使用（/monthly-data, /market-analysis）

エンドポイント例:
  GET    /api/clinics/{clinic_id}           # 取得
  POST   /api/clinics                       # 作成
  PUT    /api/clinics/{clinic_id}           # 更新
  DELETE /api/clinics/{clinic_id}           # 削除
  GET    /api/clinics/{clinic_id}/reports   # 関連リソース
```

##### 2. バージョニング戦略
```python
# URLパスによるバージョニング（推奨）
@app.get("/api/v1/clinics/{clinic_id}")
async def get_clinic_v1(clinic_id: str):
    pass

@app.get("/api/v2/clinics/{clinic_id}")
async def get_clinic_v2(clinic_id: str):
    pass

# ヘッダーによるバージョニング（柔軟性高）
@app.get("/api/clinics/{clinic_id}")
async def get_clinic(clinic_id: str, api_version: str = Header("v1")):
    if api_version == "v1":
        return get_clinic_v1_logic(clinic_id)
    elif api_version == "v2":
        return get_clinic_v2_logic(clinic_id)
```

##### 3. トレーサビリティの確保
```python
# Correlation-ID、X-Request-ID、X-Trace-IDの使用
from fastapi import Request
import uuid

@app.middleware("http")
async def add_trace_id(request: Request, call_next):
    trace_id = request.headers.get("X-Trace-ID", str(uuid.uuid4()))
    request.state.trace_id = trace_id

    response = await call_next(request)
    response.headers["X-Trace-ID"] = trace_id
    return response
```

##### 4. エラーハンドリングの統一
```python
from fastapi import HTTPException
from pydantic import BaseModel

class ErrorResponse(BaseModel):
    error_code: str
    message: str
    details: dict | None = None
    trace_id: str

@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    return JSONResponse(
        status_code=exc.status_code,
        content=ErrorResponse(
            error_code=f"ERR_{exc.status_code}",
            message=exc.detail,
            trace_id=request.state.trace_id
        ).model_dump()
    )
```

**参考資料**:
- [Web API 設計のベスト プラクティス - Azure Architecture Center](https://learn.microsoft.com/ja-jp/azure/architecture/best-practices/api-design)
- [API設計スキルを次のレベルに引き上げるベストプラクティス22選](https://qiita.com/baby-degu/items/6f516189445d98ddbb7d)
- [エンジニアが知るべきAPI設計のベストプラクティス](https://note.com/oboe692/n/n3da5ac4ddcc3)

---

### 2.2 データベース設計の課題

#### 課題の詳細
- スキーマ設計の不備
- N+1クエリ問題
- インデックス設計の欠如
- スケーラビリティの限界

#### 推奨ツール・アプローチ

| ツール/技術 | 用途 | 評価 | 備考 |
|-----------|------|------|------|
| **Supabase** | PostgreSQL BaaS | ⭐⭐⭐⭐⭐ | Auth、Storage、RLS統合 |
| **Prisma** | TypeScript ORM | ⭐⭐⭐⭐ | マイグレーション管理が優秀 |
| **Drizzle ORM** | 軽量TypeScript ORM | ⭐⭐⭐⭐ | 2026年注目株 |
| **Redis** | キャッシュ・セッション管理 | ⭐⭐⭐⭐⭐ | パフォーマンス最適化に必須 |

#### データベース設計のベストプラクティス

##### 1. インデックス設計
```sql
-- 頻繁に検索されるカラムにインデックス
CREATE INDEX idx_monthly_data_clinic_year
ON monthly_data(clinic_id, year_month);

-- 複合インデックスの順序に注意（選択性の高い順）
CREATE INDEX idx_users_role_status
ON users(role, status, created_at);

-- 部分インデックス（条件付きインデックス）でサイズ削減
CREATE INDEX idx_active_users
ON users(email) WHERE status = 'active';
```

##### 2. N+1問題の解決
```python
# ❌ 悪い例: N+1クエリ
clinics = await db.query("SELECT * FROM clinics")
for clinic in clinics:
    monthly_data = await db.query(
        "SELECT * FROM monthly_data WHERE clinic_id = ?",
        clinic.id
    )

# ✅ 良い例: JOINまたはバッチクエリ
query = """
    SELECT c.*, md.*
    FROM clinics c
    LEFT JOIN monthly_data md ON c.id = md.clinic_id
"""
result = await db.query(query)
```

##### 3. Supabase RLSによるセキュリティ
```sql
-- Row Level Security（必須設定）
ALTER TABLE clinics ENABLE ROW LEVEL SECURITY;

-- 医院オーナーは自医院のみアクセス可能
CREATE POLICY "clinic_owner_policy" ON clinics
    FOR ALL
    USING (
        auth.uid() = owner_user_id
        OR auth.jwt() ->> 'role' = 'system_admin'
    );

-- 編集者は自医院データの閲覧・編集のみ
CREATE POLICY "clinic_editor_policy" ON monthly_data
    FOR ALL
    USING (
        clinic_id IN (
            SELECT clinic_id FROM user_clinic_access
            WHERE user_id = auth.uid()
        )
    );
```

##### 4. パフォーマンス最適化
```python
# Redisキャッシュの活用
import redis
from fastapi import Depends

redis_client = redis.Redis(host='localhost', port=6379, decode_responses=True)

async def get_clinic_with_cache(clinic_id: str):
    # キャッシュ確認
    cache_key = f"clinic:{clinic_id}"
    cached = redis_client.get(cache_key)
    if cached:
        return json.loads(cached)

    # DBから取得
    clinic = await db.get_clinic(clinic_id)

    # キャッシュに保存（5分間）
    redis_client.setex(cache_key, 300, json.dumps(clinic))
    return clinic
```

**参考資料**:
- [Supabase + SPA開発で「RLS」が必須な理由](https://qiita.com/f_uto/items/c548dd663f676e0832a6)
- [Supabase サービスと料金ガイド 2025](https://qiita.com/okikusan-public/items/db9b57009b2688289f2e)

---

### 2.3 認証・セキュリティの課題

#### 課題の詳細
- パスワード管理の脆弱性
- JWT トークンの誤った実装
- CSRF、XSS、SQL Injectionのリスク
- API キーの露出

#### 推奨ツール・実装パターン

| ツール/手法 | 用途 | 評価 | 備考 |
|-----------|------|------|------|
| **Supabase Auth** | 認証基盤 | ⭐⭐⭐⭐⭐ | OAuth、MFA対応 |
| **bcrypt/argon2** | パスワードハッシュ化 | ⭐⭐⭐⭐⭐ | argon2が最新推奨 |
| **JWT** | トークンベース認証 | ⭐⭐⭐⭐ | 適切な実装が必須 |
| **OWASP ZAP** | セキュリティスキャン | ⭐⭐⭐⭐ | 脆弱性自動検出 |

#### セキュリティ実装のベストプラクティス

##### 1. パスワードハッシュ化（FastAPI）
```python
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)
```

##### 2. OAuth2 + JWT認証
```python
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

async def get_current_user(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception

    user = await get_user_from_db(user_id)
    if user is None:
        raise credentials_exception
    return user
```

##### 3. CORS設定
```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "https://ma-pilot.vercel.app",  # 本番環境
        "http://localhost:3247"          # 開発環境
    ],
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["*"],
    max_age=600,  # プリフライトリクエストのキャッシュ（秒）
)
```

##### 4. レート制限
```python
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

@app.post("/api/auth/login")
@limiter.limit("5/minute")  # 1分間に5回まで
async def login(request: Request, credentials: LoginCredentials):
    pass
```

##### 5. 環境変数管理
```python
# .env.local（絶対にGit管理しない）
DATABASE_URL=postgresql://...
SUPABASE_SERVICE_ROLE_KEY=eyJ...  # service_roleキーは絶対に露出禁止
JWT_SECRET_KEY=your-secret-key

# settings.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    database_url: str
    supabase_service_role_key: str
    jwt_secret_key: str

    class Config:
        env_file = ".env.local"

settings = Settings()
```

##### 6. Supabase AuthとFastAPIの統合
```python
# パターン1: フロントエンドから直接Supabase Auth認証
# → FastAPIはservice_roleキーでデータアクセス

# パターン2: FastAPI経由で認証（推奨）
from supabase import create_client

supabase = create_client(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)

@app.post("/api/auth/signup")
async def signup(email: str, password: str):
    try:
        result = supabase.auth.sign_up({
            "email": email,
            "password": password
        })
        return {"message": "Signup successful", "user": result.user}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
```

#### セキュリティチェックリスト
- [ ] パスワードはbcrypt/argon2でハッシュ化
- [ ] JWTトークンに有効期限を設定（15分〜1時間推奨）
- [ ] リフレッシュトークンで長期セッション管理
- [ ] HTTPS必須（本番環境）
- [ ] CORS設定で許可オリジンを明示
- [ ] レート制限でブルートフォース攻撃対策
- [ ] 環境変数で機密情報を管理
- [ ] Supabase RLSで行レベルセキュリティ
- [ ] 入力バリデーション（Pydantic）
- [ ] SQL Injection対策（ORM使用、生SQL禁止）

**参考資料**:
- [FastAPI Security Best Practices: From Authentication & Authorization to CORS](https://blog.greeden.me/en/2025/07/29/fastapi-security-best-practices-from-authentication-authorization-to-cors/)
- [セキュリティ - 最初の一歩 - FastAPI](https://fastapi.tiangolo.com/ja/tutorial/security/first-steps/)
- [Supabase Authを使って爆速で安全なアプリケーションを開発する方法](https://giginc.co.jp/blog/giglab/supabase-auth)
- [FastAPIチュートリアルの「OAuth2、JWTトークンによるBearer」がよくわからなかったので、調べてみた](https://note.com/mega_gorilla/n/ncec503b5eb8d)

---

## 3. 統合テストの課題

### 3.1 E2Eテストの課題

#### 課題の詳細
- テスト実行時間の長さ
- 環境依存による不安定性（flaky tests）
- テストコードのメンテナンスコスト
- CI/CDパイプラインでの実行時間

#### 推奨ツール比較（2026年版）

| ツール | 評価 | 強み | 弱み | 推奨規模 |
|--------|------|------|------|---------|
| **Playwright** | ⭐⭐⭐⭐⭐ | 高速、並列実行、トレースビューワー | 学習コスト中 | 中〜大規模 |
| **Cypress** | ⭐⭐⭐⭐ | DX良好、デバッグ容易 | 並列実行に制約 | 小〜中規模 |
| **Autify** | ⭐⭐⭐⭐ | ノーコード、AI自動修正 | コスト高 | 非エンジニアチーム |
| **Selenium** | ⭐⭐⭐ | 成熟、多言語対応 | 遅い、複雑 | レガシーシステム |

#### Playwright vs Cypress 詳細比較

##### パフォーマンス
```yaml
Playwright:
  - 並列実行: ローカル・CI両方で容易
  - ブラウザ起動オーバーヘッド: あり
  - テスト実行速度: 高速
  - CI実行時間: 短い

Cypress:
  - 並列実行: 有料プラン必要（Cypress Cloud）
  - ブラウザ起動オーバーヘッド: なし（常時起動）
  - テスト実行速度: 高速
  - CI実行時間: やや長い
```

##### 機能面
```yaml
Playwright:
  - スクリーンレコーディング: ✅
  - ビデオキャプチャ: ✅
  - トレースビューワー: ✅（非常に便利）
  - コード生成: ✅（VSCode拡張機能）
  - ブラウザサポート: Chromium, Firefox, WebKit

Cypress:
  - スクリーンレコーディング: ❌
  - ビデオキャプチャ: ✅
  - トレースビューワー: ❌
  - コード生成: ⚠️（限定的）
  - ブラウザサポート: Chrome, Firefox, Edge
  - GUIランナー: ✅（開発体験が良い）
```

##### 実装の複雑さ
```typescript
// Playwright: シンプルな記法
import { test, expect } from '@playwright/test';

test('ログインテスト', async ({ page }) => {
  await page.goto('http://localhost:3247/login');
  await page.fill('input[name="email"]', 'admin@example.com');
  await page.fill('input[name="password"]', 'password');
  await page.click('button[type="submit"]');
  await expect(page).toHaveURL('/dashboard');
});

// Cypress: メソッドチェーン記法（クセが強い）
describe('ログインテスト', () => {
  it('正常系', () => {
    cy.visit('http://localhost:3247/login');
    cy.get('input[name="email"]').type('admin@example.com');
    cy.get('input[name="password"]').type('password');
    cy.get('button[type="submit"]').click();
    cy.url().should('include', '/dashboard');
  });
});
```

#### 実践事例から学ぶ移行判断

##### estie社: CypressからPlaywrightへ移行
```yaml
理由:
  - VSCode拡張機能によるコード自動生成
  - トレースビューワーでデバッグが容易
  - 並列実行の容易さ

結果:
  - 開発速度向上
  - テスト実行時間短縮
```

##### Zenn: E2Eテスト基盤をPlaywrightにリプレイス
```yaml
理由:
  - ローカル・CI両方で並列実行がシンプル
  - メソッドチェーンのクセが強いCypressを避けたい
  - iframe内での制約がない

結果:
  - CI実行時間が大幅短縮
  - 開発体験の向上
```

#### 選定基準（2026年版）
```yaml
Playwrightを選ぶべきケース:
  - テスト数が多く、並列実行で時間短縮したい
  - トレースビューワーでのデバッグが必要
  - 複数ブラウザでのテストが必要
  - 新規プロジェクト

Cypressを選ぶべきケース:
  - 既存プロジェクトでCypressを使用中
  - 開発中の手動テスト実行を重視
  - GUIランナーでの視覚的な確認が重要
  - 小規模プロジェクト
```

**参考資料**:
- [E2Eテスト自動化変遷 〜ノーコードからCypress、そしてPlaywrightへ〜](https://www.estie.jp/blog/entry/2023/09/19/133816)
- [ZennのE2Eテスト基盤をリプレイスしました（開発体験向上、CI時間の短縮、Playwright移行）](https://zenn.dev/team_zenn/articles/zenn-e2e-replace-to-playwright)
- [E2Eテストの運用課題を Playwright に置き換えることで解決する](https://findy-tools.io/products/playwright/33/107)
- [CypressはPlaywrightに負けてない](https://qiita.com/ay5399/items/d6959d20b6a05b52f60e)

---

### 3.2 負荷テスト・パフォーマンステストの課題

#### 課題の詳細
- 本番環境での突発的な負荷増加
- ボトルネックの特定困難
- 負荷テストの実施コスト
- 現実的な負荷シナリオの作成

#### 推奨ツール

| ツール | 用途 | 評価 | 備考 |
|--------|------|------|------|
| **k6** | 負荷テストツール | ⭐⭐⭐⭐⭐ | 軽量、JavaScript記述、CLI実行 |
| **Locust** | Python負荷テスト | ⭐⭐⭐⭐ | Web UI付き、分散実行可能 |
| **Artillery** | モダン負荷テスト | ⭐⭐⭐⭐ | YAML設定、CI統合容易 |
| **JMeter** | 老舗負荷テスト | ⭐⭐⭐ | 機能豊富だが重い |

#### 実装例（k6）
```javascript
import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
  stages: [
    { duration: '1m', target: 50 },   // 1分で50ユーザーまで増加
    { duration: '3m', target: 50 },   // 3分間50ユーザー維持
    { duration: '1m', target: 100 },  // 1分で100ユーザーまで増加
    { duration: '3m', target: 100 },  // 3分間100ユーザー維持
    { duration: '1m', target: 0 },    // 1分でユーザー数を0に
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'], // 95%のリクエストが500ms以内
    http_req_failed: ['rate<0.01'],   // エラー率1%未満
  },
};

export default function () {
  const res = http.get('https://api.ma-pilot.com/api/clinics/123');

  check(res, {
    'status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
  });

  sleep(1);
}
```

#### CI/CDへの統合
```yaml
# GitHub Actions
name: Load Test

on:
  schedule:
    - cron: '0 2 * * 1'  # 毎週月曜日2時に実行
  workflow_dispatch:

jobs:
  load-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run k6 load test
        uses: grafana/k6-action@v0.3.0
        with:
          filename: tests/load-test.js
          cloud: true
          token: ${{ secrets.K6_CLOUD_TOKEN }}
```

**参考資料**:
- [テスト - DevOps用語集 2023年版](https://licensecounter.jp/devops-hub/blog/-devops-test/)
- [大規模なE2EテストにCircleCIを適用 テストの負荷を削減し、開発体制の充実につなげる](https://circleci.com/ja/case-studies/plaid/)

---

### 3.3 セキュリティテストの課題

#### 課題の詳細
- OWASP Top 10の脆弱性
- 依存パッケージの脆弱性
- 設定ミスによるセキュリティホール
- 定期的なセキュリティ監査

#### 推奨ツール

| ツール | 用途 | 評価 | 備考 |
|--------|------|------|------|
| **OWASP ZAP** | 動的セキュリティテスト | ⭐⭐⭐⭐⭐ | 無料、自動スキャン |
| **Snyk** | 依存パッケージ脆弱性検査 | ⭐⭐⭐⭐⭐ | CI統合、自動PR作成 |
| **npm audit** | Node.js脆弱性検査 | ⭐⭐⭐⭐ | npm標準機能 |
| **Trivy** | コンテナイメージスキャン | ⭐⭐⭐⭐ | Docker/Kubernetes対応 |
| **SonarQube** | 静的解析・コード品質 | ⭐⭐⭐⭐ | セキュリティルール搭載 |

#### 実装例
```yaml
# GitHub Actions: 自動セキュリティスキャン
name: Security Scan

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  schedule:
    - cron: '0 0 * * 0'  # 毎週日曜日0時

jobs:
  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      # 依存パッケージの脆弱性スキャン
      - name: Run Snyk
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

      # OWASP ZAPによる動的スキャン
      - name: ZAP Scan
        uses: zaproxy/action-baseline@v0.7.0
        with:
          target: 'https://staging.ma-pilot.com'
```

#### セキュリティチェックリスト
- [ ] 依存パッケージの定期更新（週次）
- [ ] OWASP Top 10の対策実装
- [ ] 環境変数の適切な管理
- [ ] HTTPSの強制（HSTS設定）
- [ ] CSP（Content Security Policy）設定
- [ ] レート制限の実装
- [ ] 入力バリデーションの徹底
- [ ] セッション管理の適切な実装

**参考資料**:
- [E2Eテストとは？4つの観点と実施する目的・自動化ツールをご紹介](https://www.qbook.jp/column/2001.html)
- [E2Eテスト自動化の完全ガイド｜ソフトウェアテストの効率アップと品質向上を同時に実現する](https://www.fsi-embedded.jp/solutions/automated-testing/what-is-automated-E2E-testing/)

---

## 4. デプロイの課題

### 4.1 環境差異の課題

#### 課題の詳細
- ローカル環境と本番環境の差異
- 環境変数の設定ミス
- Node.jsバージョンの不一致
- ビルド成功したがデプロイ失敗

#### 推奨ツール

| ツール | 用途 | 評価 | 備考 |
|--------|------|------|------|
| **Docker** | 環境統一 | ⭐⭐⭐⭐⭐ | 本番環境との差異を最小化 |
| **Docker Compose** | ローカル開発環境 | ⭐⭐⭐⭐⭐ | 複数サービスの統合管理 |
| **dotenv** | 環境変数管理 | ⭐⭐⭐⭐ | 必須ツール |
| **nvm** | Node.jsバージョン管理 | ⭐⭐⭐⭐ | チーム開発必須 |

#### 実装例

##### 1. Dockerによる環境統一
```dockerfile
# フロントエンド: Dockerfile
FROM node:20-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

```dockerfile
# バックエンド: Dockerfile
FROM python:3.11-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .
EXPOSE 8432
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8432"]
```

##### 2. Docker Composeでローカル開発環境
```yaml
version: '3.8'

services:
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.dev
    ports:
      - "3247:3247"
    volumes:
      - ./frontend:/app
      - /app/node_modules
    environment:
      - VITE_API_URL=http://localhost:8432

  backend:
    build:
      context: ./backend
    ports:
      - "8432:8432"
    volumes:
      - ./backend:/app
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - SUPABASE_URL=${SUPABASE_URL}
    depends_on:
      - db

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_PASSWORD=password
    ports:
      - "5433:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:
```

##### 3. 環境変数の管理
```bash
# .env.example（Git管理OK）
VITE_SUPABASE_URL=https://xxxxx.supabase.co
VITE_SUPABASE_ANON_KEY=your-anon-key-here
DATABASE_URL=postgresql://user:password@localhost:5433/dbname
BACKEND_URL=http://localhost:8432

# .env.local（Git管理NG）
VITE_SUPABASE_URL=https://real-project.supabase.co
VITE_SUPABASE_ANON_KEY=eyJhb...real-key
DATABASE_URL=postgresql://...real-connection-string
```

##### 4. Node.jsバージョン管理
```json
// package.json
{
  "engines": {
    "node": ">=20.0.0",
    "npm": ">=10.0.0"
  }
}
```

```bash
# .nvmrc
20.11.0
```

```yaml
# Vercel設定: vercel.json
{
  "buildCommand": "npm run build",
  "outputDirectory": "dist",
  "framework": "vite",
  "env": {
    "NODE_VERSION": "20.11.0"
  }
}
```

#### トラブルシューティング事例

##### 問題1: 環境変数が反映されない
```yaml
原因:
  - Vercelでは環境変数設定後、再デプロイが必要
  - ビルド時に読み込まれるため、デプロイ後の設定は無効

解決策:
  1. Vercelダッシュボードで環境変数を設定
  2. Redeploy（再デプロイ）を実行
```

##### 問題2: ローカルとVercel環境のNode.jsバージョン差異
```yaml
原因:
  - ローカル: Node.js 18
  - Vercel: Node.js 20（デフォルト）
  - → 依存パッケージの互換性問題

解決策:
  - .nvmrc または vercel.json で明示的にバージョン指定
```

**参考資料**:
- [【保存版】Vercelデプロイで失敗しない！環境変数の正しい設定方法と注意点](https://qiita.com/CodeLeaf/items/c3e85f32d5d34c927a77)
- [おばあちゃんでもわかるVercelデプロイトラブル解説（専門用語付き）](https://note.com/daichi_mu/n/nd5d442108163)
- [Vercel デプロイエラーの解決方法（Next.js 15対応）](https://zenn.dev/ryoushin/articles/027b9b8bbd9be4)

---

### 4.2 CI/CDパイプラインの課題

#### 課題の詳細
- デプロイ時間の長さ
- テスト失敗時の自動ロールバック
- 複数環境（dev/staging/prod）の管理
- CI/CDツールのコスト

#### 推奨ツール比較（2026年版）

| ツール | 初期コスト | ランニングコスト | 評価 | 推奨ケース |
|--------|----------|----------------|------|-----------|
| **GitHub Actions** | 無料 | 無料枠あり（月$10-20） | ⭐⭐⭐⭐⭐ | GitHubユーザー全般 |
| **CircleCI** | 無料 | 無料枠あり、有料$15/ユーザー | ⭐⭐⭐⭐ | 並列実行重視 |
| **GitLab CI/CD** | 無料 | 無料枠あり | ⭐⭐⭐⭐ | GitLabユーザー |
| **Jenkins** | 無料 | サーバー維持費（月$400-800） | ⭐⭐⭐ | オンプレミス必須 |

#### コスト比較（2026年版）

##### GitHub Actions
```yaml
無料枠:
  - パブリックリポジトリ: 完全無料
  - プライベートリポジトリ: 月2,000分無料
  - セルフホストランナー: 2026年3月から$0.002/分

小規模チーム:
  - 実質コスト: 月$10-20程度（無料枠超過分）

注意点:
  - 2026年3月からセルフホストランナーの課金開始
```

##### CircleCI
```yaml
無料枠:
  - 月6,000分のビルド時間
  - 1並列実行

小規模チーム:
  - 無料枠で十分な場合が多い
  - 有料プラン: $15/ユーザー

スケールメリット:
  - 並列実行による高速化
  - キャッシュ機能が優秀
```

##### Jenkins
```yaml
初期コスト:
  - ツール自体: 無料（オープンソース）
  - サーバー構築: 初期費用あり

ランニングコスト:
  - サーバー維持費: 月$400-800
  - メンテナンス時間: 週5-10時間（年間$15,000-30,000相当）

推奨ケース:
  - オンプレミス必須の場合
  - 既存Jenkins運用がある場合
```

#### GitHub Actions実装例（MA-Pilot）

##### 1. CI（継続的インテグレーション）
```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  frontend-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Lint
        run: npm run lint

      - name: Type check
        run: npm run type-check

      - name: Build
        run: npm run build

      - name: Unit tests
        run: npm run test

  backend-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: pip install -r requirements.txt

      - name: Lint
        run: ruff check .

      - name: Type check
        run: mypy .

      - name: Tests
        run: pytest
```

##### 2. CD（継続的デリバリー）
```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [main]

jobs:
  deploy-frontend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'

  deploy-backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Deploy to Render
        run: |
          curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK_URL }}
```

##### 3. 複数環境対応
```yaml
name: Deploy (Multi-Environment)

on:
  push:
    branches:
      - develop    # Staging環境
      - main       # Production環境

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set environment variables
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "ENVIRONMENT=production" >> $GITHUB_ENV
            echo "VERCEL_ENV=production" >> $GITHUB_ENV
          else
            echo "ENVIRONMENT=staging" >> $GITHUB_ENV
            echo "VERCEL_ENV=preview" >> $GITHUB_ENV
          fi

      - name: Deploy
        run: |
          echo "Deploying to ${{ env.ENVIRONMENT }}"
          # デプロイコマンド...
```

#### 選定基準
```yaml
GitHub Actionsを選ぶべきケース:
  - GitHubでコード管理している
  - 小〜中規模チーム
  - コストを抑えたい
  - 簡単にCI/CDを始めたい

CircleCIを選ぶべきケース:
  - 並列実行で高速化したい
  - E2Eテストなど高負荷テストを実行
  - 複雑なワークフローが必要
  - 予算に余裕がある

Jenkinsを選ぶべきケース:
  - オンプレミス必須
  - 既存Jenkins運用がある
  - 完全なカスタマイズが必要
```

**参考資料**:
- [CI/CD at scale: A performance analysis of CircleCI vs GitHub Actions](https://circleci.com/blog/ci-cd-at-scale-circleci-vs-github-actions/)
- [CircleCIとは？他のCI/CDツールとの比較から料金体系まで詳しく解説](https://www.i3design.jp/in-pocket/11601)
- [Github Actions 入門 ~概要・競合比較・おすすめの書き方など~](https://recruit.gmo.jp/engineer/jisedai/blog/github-actions-entry/)
- [CIツール コスト比較 GithubActions,TravisCI,CircleCI](https://chariosan.com/2020/07/19/comparison_ci_tool_cost/)

---

### 4.3 ダウンタイムとロールバックの課題

#### 課題の詳細
- デプロイ中のサービス停止
- 新バージョンの不具合
- 迅速なロールバックの必要性
- ユーザー影響の最小化

#### 推奨デプロイ戦略

| 戦略 | ダウンタイム | ロールバック速度 | 複雑度 | 推奨ケース |
|------|------------|----------------|--------|-----------|
| **Blue-Green** | ゼロ | 即座 | ⭐⭐⭐ | 本番環境推奨 |
| **Canary** | ゼロ | 段階的 | ⭐⭐⭐⭐ | 大規模サービス |
| **Rolling** | ほぼゼロ | やや遅い | ⭐⭐ | Kubernetes環境 |
| **Feature Flag** | ゼロ | 即座 | ⭐⭐ | 機能リリース |

#### デプロイ戦略詳細

##### 1. Blue-Greenデプロイメント
```yaml
概要:
  - 2つの並列環境（Blue: 旧、Green: 新）を用意
  - Greenにデプロイ後、ルーティングを切り替え
  - 問題があればBlueに即座に戻す

メリット:
  - ダウンタイムゼロ
  - 即座のロールバック
  - デプロイ前に本番環境でテスト可能

デメリット:
  - 2倍のリソースが必要
  - データベース移行が複雑になる場合がある

実装例（Vercel）:
  1. 本番環境（Blue）: https://ma-pilot.vercel.app
  2. 新バージョンをデプロイ（Green）: https://ma-pilot-green.vercel.app
  3. 動作確認後、ドメインを切り替え
  4. 問題があればドメインを戻す
```

##### 2. カナリアリリース
```yaml
概要:
  - 新バージョンを少数のユーザーに段階的に公開
  - 問題なければ徐々に展開率を上げる
  - 例: 5% → 25% → 50% → 100%

メリット:
  - リスクの最小化
  - 本番環境での実ユーザーテスト
  - 段階的なロールバック

デメリット:
  - 複雑なルーティング設定が必要
  - 監視が重要

実装例（Render + Flagger）:
  apiVersion: flagger.app/v1beta1
  kind: Canary
  metadata:
    name: ma-pilot-backend
  spec:
    targetRef:
      apiVersion: apps/v1
      kind: Deployment
      name: backend
    service:
      port: 8432
    analysis:
      interval: 1m
      threshold: 5
      maxWeight: 50
      stepWeight: 10
```

##### 3. Feature Flag
```typescript
// 環境変数またはリモート設定で機能を制御
import { useFeatureFlag } from '@/hooks/useFeatureFlag';

export const Dashboard = () => {
  const { isEnabled } = useFeatureFlag('new-dashboard-design');

  return isEnabled ? <NewDashboard /> : <OldDashboard />;
};

// LaunchDarkly, Unleash, PostHogなどのツールを使用
```

#### ロールバック実装例

##### 1. Vercel（フロントエンド）
```bash
# CLIでロールバック
vercel rollback

# ダッシュボードから特定のデプロイメントに戻す
# → 即座にロールバック完了
```

##### 2. Render（バックエンド）
```yaml
# Renderの自動ロールバック設定
services:
  - type: web
    name: ma-pilot-backend
    env: python
    plan: standard
    healthCheckPath: /health
    autoDeploy: true
    # ヘルスチェック失敗時に自動ロールバック
```

##### 3. AWS CodeDeploy
```python
# Lambda関数による自動検証とロールバック
import boto3

def lambda_handler(event, context):
    codedeploy = boto3.client('codedeploy')

    # デプロイ後の検証
    if not validate_deployment():
        # ロールバック実行
        codedeploy.stop_deployment(
            deploymentId=event['deploymentId'],
            autoRollbackEnabled=True
        )
        return {'status': 'ROLLBACK'}

    return {'status': 'SUCCESS'}
```

#### デプロイチェックリスト
- [ ] ヘルスチェックエンドポイントの実装
- [ ] ロールバック手順の文書化
- [ ] デプロイ前のバックアップ
- [ ] 監視アラートの設定
- [ ] カナリアリリースまたはBlue-Greenの採用
- [ ] Feature Flagで機能リリースを制御
- [ ] デプロイ後の動作確認手順

**参考資料**:
- [カナリアリリースとブルーグリーン・デプロイメント: ダウンタイム ...](https://circleci.com/blog/canary-vs-blue-green-downtime/)
- [【One Tech #10】運用目線からデプロイ戦略について語ってみた！](https://www.softbank.jp/biz/blog/cloud-technology/articles/202303/deployment/)
- [CD(継続的デリバリー)とは？ | わかりやすく解説](https://cloudbees.techmatrix.jp/devops/cd/)
- [【AWS Code シリーズ】AWS CodeDeploy でロールバック時に削除されないリソースを自動削除するように実装してみた](https://aws.taf-jp.com/blog/92208)

---

## 5. 保守・運用の課題

### 5.1 監視・ログ管理の課題

#### 課題の詳細
- エラーの検知遅延
- ログの散在と検索困難
- パフォーマンス劣化の気づきにくさ
- トラブルシューティングの時間コスト

#### 推奨ツール（APM: Application Performance Monitoring）

| ツール | 評価 | 強み | 無料枠 | 価格帯 |
|--------|------|------|--------|--------|
| **Datadog** | ⭐⭐⭐⭐⭐ | 統合監視、高機能 | あり | $15/host/月〜 |
| **Sentry** | ⭐⭐⭐⭐⭐ | エラートラッキング特化 | あり | $26/月〜 |
| **Splunk APM** | ⭐⭐⭐⭐ | エンタープライズ向け | なし | 高額 |
| **Site24x7** | ⭐⭐⭐⭐ | 外形監視、APM統合 | あり | 低価格 |
| **Google Cloud Logging** | ⭐⭐⭐⭐ | GCP統合 | 50GB/月無料 | 従量課金 |

#### ツール選定基準（スタートアップ向け）

##### Sentryを選ぶべきケース
```yaml
適用ケース:
  - アプリケーションエラーの検知と追跡がメイン
  - フロントエンド/バックエンドのエラー管理
  - コストを抑えたい

機能:
  - エラー自動グルーピング
  - スタックトレース表示
  - ブレッドクラム機能（エラー発生までの操作履歴）
  - GitHub/Slack統合

無料枠: 5,000イベント/月
有料プラン: $26/月（50,000イベント）
```

##### Datadogを選ぶべきケース
```yaml
適用ケース:
  - インフラ、APM、ログ管理を統合したい
  - サービス全体のパフォーマンス監視
  - トレーシング機能が必要

機能:
  - インフラ監視（CPU、メモリ、ディスク）
  - APM（アプリケーションパフォーマンス監視）
  - ログ管理と検索
  - ダッシュボード作成

無料枠: 1ホスト、ログ保持3日間
有料プラン: $15/host/月〜
```

##### Sentry + Datadogの併用パターン（実践事例）
```yaml
パターン:
  - Sentry: エラートラッキング専用
  - Datadog: インフラ監視、パフォーマンス分析、ログ管理

メリット:
  - Sentryのエラーグルーピングが優秀
  - Datadogで包括的な監視が可能
  - エラー発生時にDatadogのメトリクスとログを参照

実装例（VISASQ社）:
  1. SentryでHTTPリクエストのTrace IDを取得
  2. X-Cloud-Trace-Contextから抽出
  3. SentryのカスタムタグにTrace IDを追加
  4. DatadogでTrace IDを検索してログ・メトリクスを調査
```

#### 実装例

##### 1. Sentry設定（フロントエンド）
```typescript
// main.tsx
import * as Sentry from "@sentry/react";

Sentry.init({
  dsn: import.meta.env.VITE_SENTRY_DSN,
  environment: import.meta.env.MODE,
  tracesSampleRate: 1.0,  // パフォーマンス監視（100%サンプリング）
  replaysSessionSampleRate: 0.1,  // セッションリプレイ（10%）
  replaysOnErrorSampleRate: 1.0,   // エラー時は100%記録

  integrations: [
    new Sentry.BrowserTracing(),
    new Sentry.Replay(),
  ],

  // ユーザー情報の追加
  beforeSend(event, hint) {
    const user = getUserFromStore();
    if (user) {
      event.user = {
        id: user.id,
        email: user.email,
      };
    }
    return event;
  },
});
```

##### 2. Sentry設定（バックエンド）
```python
# main.py
import sentry_sdk
from sentry_sdk.integrations.fastapi import FastApiIntegration

sentry_sdk.init(
    dsn=os.getenv("SENTRY_DSN"),
    environment=os.getenv("ENVIRONMENT", "development"),
    traces_sample_rate=1.0,
    integrations=[FastApiIntegration()],
)

@app.middleware("http")
async def add_sentry_context(request: Request, call_next):
    # ユーザー情報を追加
    user = get_current_user(request)
    if user:
        sentry_sdk.set_user({"id": user.id, "email": user.email})

    # カスタムタグを追加
    sentry_sdk.set_tag("clinic_id", request.headers.get("X-Clinic-ID"))

    response = await call_next(request)
    return response
```

##### 3. Datadog設定
```python
# Datadog APM
from ddtrace import patch_all
patch_all()

# カスタムメトリクス
from datadog import statsd

@app.post("/api/monthly-data")
async def create_monthly_data(data: MonthlyData):
    # 処理時間を計測
    with statsd.timed('monthly_data.create.duration'):
        result = await db.create_monthly_data(data)

    # カスタムメトリクス送信
    statsd.increment('monthly_data.created')

    return result
```

##### 4. ログ構造化
```python
import structlog

logger = structlog.get_logger()

@app.get("/api/clinics/{clinic_id}")
async def get_clinic(clinic_id: str, request: Request):
    logger.info(
        "clinic.fetch",
        clinic_id=clinic_id,
        user_id=request.state.user_id,
        trace_id=request.state.trace_id,
    )

    try:
        clinic = await db.get_clinic(clinic_id)
        return clinic
    except Exception as e:
        logger.error(
            "clinic.fetch.failed",
            clinic_id=clinic_id,
            error=str(e),
            trace_id=request.state.trace_id,
        )
        raise
```

#### 監視設定のベストプラクティス

##### アラート設定
```yaml
Sentryアラート:
  - 新規エラー発生時: 即座にSlack通知
  - エラー急増時: 1時間で100件以上
  - エラー再発時: 解決済みエラーが再度発生

Datadogアラート:
  - レスポンスタイム: p95が1秒超過
  - エラー率: 1%以上
  - CPU使用率: 80%以上が5分継続
  - メモリ使用率: 90%以上
  - ディスク使用率: 85%以上
```

##### ダッシュボード設計
```yaml
必須メトリクス:
  - リクエスト数/分
  - エラー率
  - レスポンスタイム（p50, p95, p99）
  - Apdex Score（アプリケーション満足度指標）
  - CPU/メモリ使用率
  - データベースクエリ時間
  - 外部APIレスポンスタイム
```

#### 実装チェックリスト
- [ ] エラートラッキングツール導入（Sentry推奨）
- [ ] APMツール導入（Datadog/Site24x7）
- [ ] 構造化ログの実装
- [ ] ヘルスチェックエンドポイント実装
- [ ] アラート設定（Slack/Email）
- [ ] ダッシュボード作成
- [ ] トレーシング実装（分散トレーシング）
- [ ] ユーザー情報のコンテキスト追加

**参考資料**:
- [Sentry+Datadogで「運用の属人化」の壁を越えようとしている話](https://tech.visasq.com/optimize-operation/)
- [ZOZOTOWNの監視にモダンなツール（Datadog、PagerDuty、Sentry）を導入した話](https://techblog.zozo.com/entry/zozotown-backend-monitoring)
- [Datadog使っているけど、Sentryによるエラートラッキング機能が便利という話](https://www.pospome.work/entry/2022/09/09/100527)
- [Datadog×Sentryで実現するエラートラッキング](https://zenn.dev/cover_corp/articles/fa3be55ecb1d78)

---

### 5.2 SRE実践：SLI/SLO/エラーバジェット

#### 課題の詳細
- サービス信頼性の定量化が困難
- 開発速度と安定性のバランス
- 障害対応の優先順位付け
- チーム間のコミュニケーション

#### 基本概念

| 用語 | 説明 | 例 |
|------|------|-----|
| **SLI** | Service Level Indicator（サービスレベル指標） | 可用性99.9%、レスポンスタイムp95<500ms |
| **SLO** | Service Level Objective（サービスレベル目標） | 月間可用性99.9%以上を維持 |
| **SLA** | Service Level Agreement（サービスレベル合意） | SLO未達成時の返金条件 |
| **エラーバジェット** | SLOで許容されるエラー量 | 可用性99.9% → 月43分のダウンタイム許容 |

#### SLI/SLO設定例

##### 1. MA-Pilotでの設定例
```yaml
可用性のSLI/SLO:
  SLI: 成功したHTTPリクエスト数 / 全HTTPリクエスト数
  SLO: 99.9%以上（月間）
  エラーバジェット: 0.1%（月43分のダウンタイム許容）

レスポンスタイムのSLI/SLO:
  SLI: APIレスポンスタイムのp95
  SLO: 500ms以下
  測定対象: /api/clinics, /api/monthly-data など主要エンドポイント

データ正確性のSLI/SLO:
  SLI: データ整合性チェックの成功率
  SLO: 99.99%以上
  測定: 日次バッチ処理の成功率
```

##### 2. 段階的SLO設定（スタートアップ向け）
```yaml
Phase 1（MVP段階）:
  - 可用性: 99%（月7時間のダウンタイム許容）
  - レスポンスタイム: p95<1秒
  - エラー率: 5%未満

Phase 2（成長期）:
  - 可用性: 99.5%（月3.6時間のダウンタイム許容）
  - レスポンスタイム: p95<500ms
  - エラー率: 1%未満

Phase 3（成熟期）:
  - 可用性: 99.9%（月43分のダウンタイム許容）
  - レスポンスタイム: p95<300ms
  - エラー率: 0.1%未満
```

#### エラーバジェット運用

##### 1. エラーバジェットの計算
```python
# エラーバジェット計算ツール
def calculate_error_budget(slo_target: float, total_requests: int) -> dict:
    """
    Args:
        slo_target: SLO目標値（例: 0.999 = 99.9%）
        total_requests: 総リクエスト数

    Returns:
        エラーバジェット情報
    """
    allowed_failures = int(total_requests * (1 - slo_target))

    return {
        "total_requests": total_requests,
        "slo_target": slo_target,
        "allowed_failures": allowed_failures,
        "downtime_minutes": (1 - slo_target) * 43200,  # 月間（分）
    }

# 例: 月間1,000,000リクエスト、SLO 99.9%
result = calculate_error_budget(0.999, 1_000_000)
# → allowed_failures: 1,000件
# → downtime_minutes: 43.2分
```

##### 2. エラーバジェットベースの開発フロー
```yaml
エラーバジェット残量に応じた対応:

残量80%以上:
  - 新機能開発を積極的に進める
  - リリース頻度を上げる
  - 多少リスクのある変更もOK

残量50-80%:
  - 通常の開発ペース
  - リリース前のテストを強化
  - 監視を注意深く行う

残量20-50%:
  - 新機能開発を抑制
  - 安定性向上にフォーカス
  - バグ修正を優先

残量0-20%:
  - 新機能開発を停止
  - 緊急のバグ修正のみ
  - 信頼性改善タスクに集中

残量0%（使い切った）:
  - 新機能リリース完全停止
  - 安定化作業のみ実施
  - ポストモーテム（事後分析）実施
```

##### 3. 実装例（Datadog Monitor）
```yaml
# Datadog Monitor設定
name: "SLO Violation: API Availability"
type: "slo alert"
query: |
  sum(last_1h):
    sum:http.request.count{status:200}.as_count()
    / sum:http.request.count.as_count()
    < 0.999
message: |
  Alert: API可用性がSLO（99.9%）を下回りました
  現在値: {{value}}%

  エラーバジェット消費状況を確認してください:
  https://app.datadoghq.com/slo/xxx

  @slack-sre-team @pagerduty-oncall
tags:
  - service:ma-pilot-api
  - team:sre
  - severity:high
```

#### SRE実践のステップ

##### 1. 初期導入（Week 1-2）
```yaml
やること:
  - SLIの選定と定義
  - SLOの初期値設定（現状+10%程度）
  - 測定ツールの導入（Datadog/Prometheus）
  - ダッシュボード作成

成果物:
  - SLI/SLO定義書
  - 監視ダッシュボード
  - アラート設定
```

##### 2. 運用開始（Week 3-4）
```yaml
やること:
  - エラーバジェットの週次レビュー
  - SLO違反時の対応フロー確立
  - チーム内での共有と理解促進

成果物:
  - エラーバジェットレポート
  - インシデント対応手順書
  - 週次レビューミーティング
```

##### 3. 改善サイクル（継続）
```yaml
やること:
  - SLO達成状況の分析
  - エラーバジェット消費パターンの特定
  - SLOの見直し（四半期ごと）
  - ポストモーテムの実施

成果物:
  - 四半期レビューレポート
  - ポストモーテムドキュメント
  - SLO改善提案
```

#### 実践事例

##### Visional社（HRMOS）
```yaml
取り組み:
  - スクラムとSREを組み合わせた運用
  - エラーバジェットをスプリント計画に組み込み
  - SLO違反時は自動的に安定化タスクを優先

結果:
  - 開発速度と安定性の両立
  - チーム間のコミュニケーション改善
  - 属人化の解消
```

##### CyberAgent SRG
```yaml
取り組み:
  - SLI/SLO導入テンプレートの作成
  - 新規チーム参加時の浸透プロセス確立
  - 具体的な資料やテンプレートを用いた説明

成果:
  - SRE文化の組織横断的な浸透
  - チーム間でのベストプラクティス共有
```

#### チェックリスト
- [ ] SLIの定義（可用性、レスポンスタイム、エラー率など）
- [ ] SLOの設定（達成可能かつ挑戦的な目標値）
- [ ] エラーバジェットの計算と可視化
- [ ] 監視ツールの導入とダッシュボード作成
- [ ] アラート設定（SLO違反時）
- [ ] エラーバジェットレビューの定例化
- [ ] ポストモーテムプロセスの確立
- [ ] チーム内での理解促進とドキュメント整備

**参考資料**:
- [円滑なエラーバジェット運用に向けた取り組み - Visional Engineering Blog](https://engineering.visional.inc/blog/302/error-budget/)
- [SLI、SLO、エラーバジェット導入の前に知っておきたいこと](https://sreake.com/blog/sli-slo-good-practices/)
- [SLI/SLO 完全ガイド - CyberAgent SRG](https://ca-srg.dev/32f7b8c96de7489094802512de434d0f)
- [SLOとエラー予算](https://yulii.github.io/service-level-objective-20201106.html)
- [信頼性向上のためのSLI/SLO導入vol.1 - 紹介と必要性](https://techblog.lycorp.co.jp/ja/20250422a)

---

## 6. プロジェクト規模別推奨構成

### 6.1 小規模プロジェクト（個人〜3人）

#### 技術スタック
```yaml
フロントエンド:
  - React + TypeScript + Vite
  - Zustand（状態管理）
  - React Query（サーバー状態）
  - MUI（UIライブラリ）
  - Tailwind CSS

バックエンド:
  - FastAPI（Python）
  - Supabase（DB、Auth、Storage）
  - Pydantic（バリデーション）

テスト:
  - Vitest（ユニットテスト）
  - Playwright（E2Eテスト、最小限）

デプロイ:
  - Vercel（フロントエンド）
  - Render.com無料枠（バックエンド）
  - GitHub Actions（CI/CD）

監視:
  - Sentry無料枠（エラートラッキング）
  - Vercel Analytics（基本メトリクス）

月額コスト: $0-50（無料枠中心）
```

#### 推奨理由
- シンプルで学習コストが低い
- 無料枠で開始可能
- スケールアウトが容易
- ドキュメントが豊富

---

### 6.2 中規模プロジェクト（4〜10人）

#### 技術スタック
```yaml
フロントエンド:
  - React + TypeScript + Vite
  - Zustand + React Query
  - MUI + Tailwind CSS
  - Turborepo（モノレポ管理）

バックエンド:
  - FastAPI
  - Supabase（本番環境）
  - PostgreSQL（開発環境はDocker）
  - Redis（キャッシュ）

テスト:
  - Vitest（ユニットテスト）
  - Playwright（E2Eテスト）
  - k6（負荷テスト）

デプロイ:
  - Vercel Pro（フロントエンド）
  - Render.com Standard（バックエンド）
  - GitHub Actions + CircleCI（CI/CD並列実行）

監視:
  - Sentry Business（エラートラッキング）
  - Datadog Starter（APM、ログ管理）
  - PagerDuty（オンコール管理）

月額コスト: $200-500
```

#### 追加の推奨事項
- モノレポ管理でコード共有
- E2Eテストの自動化
- SLI/SLOの導入
- ステージング環境の構築

---

### 6.3 大規模プロジェクト（11人以上）

#### 技術スタック
```yaml
フロントエンド:
  - React + TypeScript + Next.js
  - Redux Toolkit（複雑な状態管理）
  - MUI + カスタムデザインシステム
  - Nx（モノレポ管理、高機能）

バックエンド:
  - FastAPI（マイクロサービス化）
  - PostgreSQL（RDS/Cloud SQL）
  - Redis Cluster
  - Kafka（イベントストリーミング）

テスト:
  - Vitest + Jest
  - Playwright（並列実行）
  - k6 + Artillery（負荷テスト）
  - OWASP ZAP（セキュリティテスト）

デプロイ:
  - Vercel Enterprise / AWS CloudFront + S3
  - Kubernetes（AWS EKS / GKE）
  - GitHub Actions + CircleCI（並列CI/CD）
  - ArgoCD（GitOps）

監視:
  - Datadog Pro（統合監視）
  - Sentry Enterprise（エラートラッキング）
  - PagerDuty（オンコール管理）
  - Grafana + Prometheus（カスタムメトリクス）

月額コスト: $1,000-5,000+
```

#### 追加の推奨事項
- マイクロサービスアーキテクチャ
- カナリアリリース・Blue-Greenデプロイ
- SREチームの組織化
- エラーバジェット運用
- コンプライアンス対応（SOC2、ISO27001）

---

## 7. コスト比較表

### 7.1 開発ツール月額コスト（2026年版）

| カテゴリ | ツール | 無料枠 | 小規模 | 中規模 | 大規模 |
|---------|--------|--------|--------|--------|--------|
| **ホスティング** | Vercel | 100GB帯域 | $20/月 | $150/月 | Enterprise |
| | Render | 750時間 | $25/月 | $85/月 | $200/月+ |
| **データベース** | Supabase | 500MB, 5万MAU | $25/月 | $25/月 | $399/月+ |
| **CI/CD** | GitHub Actions | 2,000分 | $10-20/月 | $50-100/月 | $200/月+ |
| | CircleCI | 6,000分 | 無料 | $15/user | $15/user |
| **監視** | Sentry | 5,000イベント | $26/月 | $80/月 | $599/月+ |
| | Datadog | 1ホスト | $15/host | $150/月 | $1,000/月+ |
| **テスト** | Playwright | 無料 | 無料 | 無料 | 無料 |
| | Autify | なし | $500/月 | $1,000/月 | Enterprise |

### 7.2 プロジェクト規模別総コスト

| 規模 | 月額コスト | 年間コスト | 含まれるもの |
|------|----------|-----------|------------|
| **小規模** | $0-50 | $0-600 | 無料枠中心、基本機能のみ |
| **中規模** | $200-500 | $2,400-6,000 | 有料プラン、監視・テスト強化 |
| **大規模** | $1,000-5,000+ | $12,000-60,000+ | エンタープライズ、SRE体制 |

### 7.3 コスト削減のヒント

```yaml
無料枠の活用:
  - Vercel: 個人プロジェクトは完全無料
  - Render: 15分のアイドルタイムで自動スリープ（無料枠）
  - Supabase: 2プロジェクトまで無料
  - GitHub Actions: パブリックリポジトリは完全無料

オープンソースの活用:
  - Playwright: 無料のE2Eテストツール
  - Grafana + Prometheus: 無料の監視ツール（自前構築）
  - k6: 無料の負荷テストツール

段階的な導入:
  - MVP段階: 無料枠のみ
  - グロース段階: 必要なツールのみ有料化
  - スケール段階: エンタープライズプランへ移行
```

---

## 8. 実践事例から学ぶ教訓

### 8.1 技術スタック選定の失敗事例

#### Ubie社: 技術スタックの発散
```yaml
問題:
  - バックエンド言語: Kotlin、Go、Node.js、Ruby、Python
  - 技術スタックが分散し、弊害が顕在化

弊害の詳細:
  - 人材採用の困難（特定スタックのエキスパートが少ない）
  - ナレッジ共有の難しさ
  - ツール・ライブラリの重複投資
  - 保守コストの増大

解決策:
  - 技術スタックをNode.js、Goに収束
  - 長期的な採用しやすさを重視

教訓:
  - 初期段階での技術スタック統一が重要
  - 「最新技術」より「チームで使える技術」を優先
  - 技術的負債は早期に返済する
```

#### ログラス社: AngularからReactへのリプレイス
```yaml
問題:
  - Angularの採用人材が少ない
  - エコシステムがReactに劣る

解決策:
  - 長期的な採用のしやすさを考慮
  - Reactへリプレイス

教訓:
  - 人材市場を考慮した技術選定
  - 短期的な技術的優位性より、長期的な保守性を重視
```

---

### 8.2 モノレポ管理の実践

#### DeLMO社: NxからTurborepoへ移行
```yaml
背景:
  - Nxの機能が過剰
  - シンプルなモノレポ管理が目的

移行理由:
  - Turborepoの方がシンプル
  - 設定が15分で完了
  - Vercelとの統合が良好

結果:
  - 開発体験の向上
  - ビルド時間の短縮

教訓:
  - 機能が多い ≠ 良いツール
  - プロジェクト規模に応じた選定が重要
```

#### 推奨選定基準（2026年版）
```yaml
Turborepoを選ぶ:
  - 5-20プロジェクトの中規模モノレポ
  - React/Next.js中心
  - シンプルさを重視

Nxを選ぶ:
  - 20-50プロジェクトの大規模モノレポ
  - 複雑な依存関係
  - カスタムジェネレーターが必要
```

---

### 8.3 E2Eテストツール選定

#### estie社・Zenn: PlaywrightへのE2Eテスト移行
```yaml
Cypressの課題:
  - メソッドチェーン記法のクセ
  - 並列実行の制約（有料プラン必要）
  - iframe内での制約

Playwrightの利点:
  - VSCode拡張機能によるコード自動生成
  - トレースビューワーでのデバッグ
  - ローカル・CI両方で並列実行が容易

結果:
  - CI実行時間の大幅短縮
  - 開発体験の向上

教訓:
  - テスト実行時間はプロダクト開発速度に直結
  - デバッグのしやすさは重要
  - 新規プロジェクトではPlaywright推奨
```

---

### 8.4 監視・運用の実践

#### VISASQ社: Sentry + Datadogの統合運用
```yaml
課題:
  - 運用の属人化
  - エラー調査の時間コスト

解決策:
  - Sentry: エラートラッキング専用
  - Datadog: インフラ監視、ログ管理
  - Trace IDで連携

実装:
  - SentryでHTTPリクエストのTrace ID抽出
  - X-Cloud-Trace-Contextから取得
  - Datadogで同じTrace IDを検索

結果:
  - エラー調査時間の短縮
  - チーム全体での運用可能

教訓:
  - 単一ツールで全てを解決しようとしない
  - ツール間の連携が重要
  - Trace IDによる統合が効果的
```

#### ZOZO: モダンツール導入
```yaml
導入ツール:
  - Datadog: 監視SaaS
  - PagerDuty: オンコール管理
  - Sentry: エラーログ管理

統合の工夫:
  - DatadogとPagerDutyを連携
  - 深夜アラート時の自動エスカレーション
  - 一次対応者が応答しない場合、二次対応者へ自動通知

結果:
  - 運用負荷の軽減
  - 迅速なインシデント対応

教訓:
  - オンコール運用はツールで自動化
  - エスカレーションフローを事前設計
```

---

### 8.5 デプロイ戦略の実践

#### Blue-Greenデプロイメントの効果
```yaml
導入前:
  - デプロイ中にサービス停止
  - 問題発生時のロールバックに時間

導入後:
  - ダウンタイムゼロ
  - 即座のロールバック

教訓:
  - リソースコストは2倍だが、ユーザー影響ゼロ
  - 本番環境ではBlue-Green推奨
```

---

## まとめ: ツール選定の黄金律

### 1. プロジェクトの現在地を知る
```yaml
チェックリスト:
  - [ ] チーム人数は？
  - [ ] 予算は？
  - [ ] 技術スタックは？
  - [ ] リリース目標は？
```

### 2. 段階的に導入する
```yaml
Phase 1（MVP）: 無料枠中心、最小限のツール
Phase 2（グロース）: 必要なツールを有料化
Phase 3（スケール）: エンタープライズプランへ
```

### 3. 人材市場を考慮する
```yaml
優先順位:
  1. チームが使えるか？
  2. 採用しやすいか？
  3. 技術的に優れているか？
```

### 4. 長期的な保守性を重視
```yaml
判断基準:
  - コミュニティの活発さ
  - ドキュメントの充実度
  - エコシステムの成熟度
  - 将来的な移行コスト
```

### 5. 実践→測定→改善
```yaml
サイクル:
  1. ツールを導入
  2. メトリクスを測定
  3. 効果を検証
  4. 必要に応じて変更
```

---

## 参考資料まとめ

### フロントエンド開発
- [2025年版｜今どきのフロントエンド技術＆トレンドまるっと解説！](https://devworks.jp/blog/229)
- [2025年のWebフロントエンドのふりかえりと2026年](https://www.docswell.com/s/sakito/ZEY2P7-burikaigi2026)
- [Reactのパフォーマンス改善でjsの実行速度を1.85倍早くしたお話](https://medium.com/@wondernuts.staff/react%E3%81%AE%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E6%94%B9%E5%96%84%E3%81%A7js%E3%81%AE%E5%AE%9F%E8%A1%8C%E9%80%9F%E5%BA%A6%E3%82%921-85%E5%80%8D%E6%97%A9%E3%81%8F%E3%81%97%E3%81%9F%E3%81%8A%E8%A9%B1-7cc9b9d61773)

### バックエンド開発
- [Web API 設計のベスト プラクティス - Azure Architecture Center](https://learn.microsoft.com/ja-jp/azure/architecture/best-practices/api-design)
- [API設計スキルを次のレベルに引き上げるベストプラクティス22選](https://qiita.com/baby-degu/items/6f516189445d98ddbb7d)
- [FastAPI Security Best Practices](https://blog.greeden.me/en/2025/07/29/fastapi-security-best-practices-from-authentication-authorization-to-cors/)
- [Supabase + SPA開発で「RLS」が必須な理由](https://qiita.com/f_uto/items/c548dd663f676e0832a6)

### テスト
- [ZennのE2Eテスト基盤をリプレイスしました（Playwright移行）](https://zenn.dev/team_zenn/articles/zenn-e2e-replace-to-playwright)
- [E2Eテスト自動化変遷 〜ノーコードからCypress、そしてPlaywrightへ〜](https://www.estie.jp/blog/entry/2023/09/19/133816)

### デプロイ・CI/CD
- [CI/CD at scale: CircleCI vs GitHub Actions](https://circleci.com/blog/ci-cd-at-scale-circleci-vs-github-actions/)
- [カナリアリリースとブルーグリーン・デプロイメント](https://circleci.com/blog/canary-vs-blue-green-downtime/)
- [【保存版】Vercelデプロイで失敗しない！環境変数の正しい設定方法](https://qiita.com/CodeLeaf/items/c3e85f32d5d34c927a77)

### 監視・運用
- [Sentry+Datadogで「運用の属人化」の壁を越えようとしている話](https://tech.visasq.com/optimize-operation/)
- [ZOZOTOWNの監視にモダンなツール（Datadog、PagerDuty、Sentry）を導入した話](https://techblog.zozo.com/entry/zozotown-backend-monitoring)
- [円滑なエラーバジェット運用に向けた取り組み](https://engineering.visional.inc/blog/302/error-budget/)
- [SLI/SLO 完全ガイド - CyberAgent SRG](https://ca-srg.dev/32f7b8c96de7489094802512de434d0f)

### モノレポ管理
- [【2025年完全版】モノレポ管理実践ガイド](https://tasukehub.com/articles/monorepo-management-efficiency-guide-2025)
- [モノレポ管理ツールを Nx から Turborepo へ移行した話](https://tech.delm0.jp/entry/2023/05/29/161202)

### 技術スタック選定
- [言語・技術スタックまとめ 15選 - Findy Tools](https://findy-tools.io/articles/2024-tech-stack/1)
- [組織全体で技術スタックを統一している事例を調べてみた](https://dev.classmethod.jp/articles/same-tech-stacks-in-the-organization/)

---

**本ドキュメントは、MA-Pilotプロジェクトの経験と、2026年1月時点の最新情報を基に作成されています。**
**プロジェクトの状況や技術トレンドに応じて、適宜アップデートしてください。**
